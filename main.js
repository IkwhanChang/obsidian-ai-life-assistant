/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AiLifeAssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var AI_ASSISTANT_VIEW_TYPE = "ai-life-assistant-view";
var DEFAULT_SETTINGS = {
  openAiApiKey: "",
  defaultModel: "gpt-4o-mini"
};
var CHARS_PER_TOKEN = 3.5;
var MAX_CONTEXT_TOKENS = 15e3;
async function callChatGPT(apiKey, model, systemPrompt, userPrompt, context = "") {
  var _a;
  const fullPrompt = context ? `${context}

${userPrompt}` : userPrompt;
  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: fullPrompt }
        ]
      })
    });
    if (!response.ok) {
      const errorData = await response.json();
      console.error("OpenAI API Error:", errorData);
      throw new Error(
        `OpenAI API Error: ${response.status} ${((_a = errorData == null ? void 0 : errorData.error) == null ? void 0 : _a.message) || "Unknown error"}`
      );
    }
    const data = await response.json();
    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
      return data.choices[0].message.content.trim();
    } else {
      console.error("Unexpected API response structure:", data);
      throw new Error("Unexpected API response structure from OpenAI.");
    }
  } catch (error) {
    console.error("Error calling ChatGPT:", error);
    throw error;
  }
}
var AiAssistantView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // For displaying concatenated file names
    this.currentContextContent = "";
    this.plugin = plugin;
  }
  getViewType() {
    return AI_ASSISTANT_VIEW_TYPE;
  }
  getDisplayText() {
    return "AI Assistant";
  }
  getIcon() {
    return "brain-cog";
  }
  estimateTokens(text) {
    return Math.ceil(text.length / CHARS_PER_TOKEN);
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.createEl("h4", { text: "AI Life Assistant" });
    const inputRow = container.createDiv({ cls: "ai-input-row" });
    const folderSelectContainer = inputRow.createDiv({
      cls: "ai-folder-select-container"
    });
    folderSelectContainer.style.marginBottom = "10px";
    folderSelectContainer.createEl("label", {
      text: "Context Folder:",
      cls: "ai-folder-label"
    }).style.marginRight = "5px";
    this.folderSelectEl = folderSelectContainer.createEl("select");
    this.folderSelectEl.style.marginRight = "10px";
    this.populateFolderDropdown();
    this.folderSelectEl.addEventListener(
      "change",
      () => this.handleFolderSelectionChange()
    );
    const promptArea = container.createDiv({ cls: "ai-prompt-area" });
    promptArea.style.display = "flex";
    promptArea.style.alignItems = "flex-end";
    promptArea.style.gap = "8px";
    promptArea.style.marginBottom = "5px";
    this.promptInputEl = promptArea.createEl("textarea", {
      attr: { placeholder: "Enter your prompt for the AI..." }
    });
    this.promptInputEl.style.flexGrow = "1";
    this.promptInputEl.style.minHeight = "40px";
    this.promptInputEl.style.maxHeight = "200px";
    this.promptInputEl.style.resize = "vertical";
    this.promptInputEl.rows = 1;
    this.promptInputEl.addEventListener("input", () => {
      this.promptInputEl.style.height = "auto";
      this.promptInputEl.style.height = `${this.promptInputEl.scrollHeight}px`;
      this.updateTokenWarning();
    });
    const submitButton = promptArea.createEl("button", { text: "Ask AI" });
    submitButton.style.height = "min-content";
    this.tokenWarningEl = container.createEl("p", { cls: "ai-token-warning" });
    this.tokenWarningEl.style.color = "var(--text-error)";
    this.tokenWarningEl.style.fontSize = "0.9em";
    this.tokenWarningEl.style.display = "none";
    this.tokenWarningEl.style.marginBottom = "10px";
    this.concatenatedFilesListEl = container.createDiv({
      cls: "ai-concatenated-files-list"
    });
    this.concatenatedFilesListEl.style.fontSize = "0.85em";
    this.concatenatedFilesListEl.style.color = "var(--text-muted)";
    this.concatenatedFilesListEl.style.maxHeight = "100px";
    this.concatenatedFilesListEl.style.overflowY = "auto";
    this.concatenatedFilesListEl.style.border = "1px dashed var(--background-modifier-border)";
    this.concatenatedFilesListEl.style.padding = "5px";
    this.concatenatedFilesListEl.style.marginBottom = "10px";
    this.concatenatedFilesListEl.setText("No context files loaded yet.");
    this.responseDivEl = container.createDiv({ cls: "ai-response-area" });
    this.responseDivEl.style.marginTop = "8px";
    this.responseDivEl.style.borderTop = "1px solid var(--background-modifier-border)";
    this.responseDivEl.style.paddingTop = "8px";
    this.responseDivEl.style.maxHeight = "calc(100vh - 300px)";
    this.responseDivEl.style.overflowY = "auto";
    inputRow.style.display = "flex";
    inputRow.style.alignItems = "flex-end";
    inputRow.style.gap = "8px";
    inputRow.style.marginBottom = "10px";
    const handleSubmit = async () => {
      const userPromptText = this.promptInputEl.value;
      if (!userPromptText.trim()) {
        new import_obsidian.Notice("Please enter a prompt.");
        return;
      }
      const totalTokens = this.estimateTokens(
        this.currentContextContent + userPromptText
      );
      if (totalTokens > MAX_CONTEXT_TOKENS) {
        new import_obsidian.Notice(
          "Error: Combined context and prompt exceed token limit. Please shorten or select a smaller folder."
        );
        this.tokenWarningEl.setText(
          `Token limit exceeded! Current: ~${totalTokens} (Max: ${MAX_CONTEXT_TOKENS}). Shorten prompt or context.`
        );
        this.tokenWarningEl.style.display = "block";
        return;
      }
      try {
        new import_obsidian.Notice("AI\uC5D0\uAC8C \uBB3C\uC5B4\uBCF4\uB294 \uC911...");
        this.responseDivEl.empty();
        const systemPrompt = "You are a helpful AI assistant. Please format your response in Markdown.";
        const response = await this.plugin.callOpenAI(
          systemPrompt,
          userPromptText,
          this.currentContextContent
        );
        await import_obsidian.MarkdownRenderer.renderMarkdown(
          response,
          this.responseDivEl,
          this.app.vault.getRoot().path,
          // Base path for relative links
          this
          // Cast to Component
        );
        this.promptInputEl.value = "";
        this.promptInputEl.style.height = "auto";
        this.promptInputEl.rows = 1;
        this.promptInputEl.focus();
        this.updateTokenWarning();
      } catch (error) {
        this.responseDivEl.empty();
        if (error.message !== "OpenAI API Key not set.") {
          console.error("Error interacting with AI from panel:", error);
          new import_obsidian.Notice(`Error: ${error.message}. Check console for details.`);
        }
        const errorP = this.responseDivEl.createEl("p", {
          text: `Error: ${error.message}`,
          cls: "ai-error-message"
        });
        errorP.style.color = "var(--text-error)";
      }
    };
    submitButton.addEventListener("click", handleSubmit);
    this.promptInputEl.addEventListener(
      "keydown",
      async (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          await handleSubmit();
        }
      }
    );
    this.updateTokenWarning();
    setTimeout(() => this.promptInputEl.focus(), 50);
  }
  populateFolderDropdown() {
    this.folderSelectEl.empty();
    this.folderSelectEl.createEl("option", {
      text: "No folder selected",
      value: ""
    });
    const folders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian.TFolder);
    folders.sort((a, b) => a.path.localeCompare(b.path));
    for (const folder of folders) {
      if (folder.path === ".obsidian" || folder.path.startsWith(".obsidian/")) {
        continue;
      }
      this.folderSelectEl.createEl("option", {
        text: folder.path,
        value: folder.path
      });
    }
  }
  async handleFolderSelectionChange() {
    const selectedPath = this.folderSelectEl.value;
    if (selectedPath) {
      new import_obsidian.Notice(`Loading context from folder: ${selectedPath}...`);
      await this.loadContextFromFolder(selectedPath);
    } else {
      this.currentContextContent = "";
      this.updateConcatenatedFilesList([]);
      this.updateTokenWarning();
    }
  }
  async loadContextFromFolder(folderPath) {
    let concatenatedContent = "";
    let currentTokens = 0;
    const loadedFileNames = [];
    const filesInFolder = this.app.vault.getMarkdownFiles().filter((file) => {
      return file.parent && file.parent.path === folderPath;
    });
    filesInFolder.sort((a, b) => a.name.localeCompare(b.name));
    for (const file of filesInFolder) {
      const fileContent = await this.app.vault.cachedRead(file);
      const fileTokens = this.estimateTokens(fileContent);
      if (currentTokens + fileTokens + this.estimateTokens(this.promptInputEl.value) > MAX_CONTEXT_TOKENS) {
        new import_obsidian.Notice(
          `Stopped adding files to context to avoid exceeding token limit. Last file added: ${concatenatedContent ? "previous files" : "none"}. Current file skipped: ${file.name}`
        );
        break;
      }
      concatenatedContent += fileContent + "\n\n---\n\n";
      currentTokens += fileTokens + this.estimateTokens("\n\n---\n\n");
      loadedFileNames.push(file.name);
    }
    this.currentContextContent = concatenatedContent;
    this.updateConcatenatedFilesList(loadedFileNames);
    this.updateTokenWarning();
    if (concatenatedContent) {
      new import_obsidian.Notice(
        `Context loaded from ${folderPath}. Estimated context tokens: ~${this.estimateTokens(
          this.currentContextContent
        )}`
      );
    }
  }
  updateConcatenatedFilesList(fileNames) {
    this.concatenatedFilesListEl.empty();
    if (fileNames.length === 0) {
      this.concatenatedFilesListEl.setText(
        "No context files loaded from selected folder."
      );
      return;
    }
    this.concatenatedFilesListEl.createEl("strong", { text: "Context Files:" });
    const ul = this.concatenatedFilesListEl.createEl("ul");
    fileNames.forEach((name) => ul.createEl("li", { text: name }));
  }
  updateTokenWarning() {
    const promptTokens = this.estimateTokens(this.promptInputEl.value);
    const contextTokens = this.estimateTokens(this.currentContextContent);
    const totalUserTokens = promptTokens + contextTokens;
    this.tokenWarningEl.setText(
      `Context: ~${contextTokens} tokens. Prompt: ~${promptTokens} tokens. Total: ~${totalUserTokens} / ${MAX_CONTEXT_TOKENS} tokens.`
    );
    this.tokenWarningEl.style.display = totalUserTokens > 0 ? "block" : "none";
    this.tokenWarningEl.style.color = totalUserTokens > MAX_CONTEXT_TOKENS ? "var(--text-error)" : "var(--text-muted)";
  }
  async onClose() {
  }
};
var AiLifeAssistantPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      AI_ASSISTANT_VIEW_TYPE,
      (leaf) => new AiAssistantView(leaf, this)
    );
    this.addRibbonIcon("brain-cog", "Toggle AI Assistant Panel", () => {
      this.activateView();
    });
    this.addCommand({
      id: "toggle-ai-assistant-panel",
      name: "Toggle AI Assistant Panel",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "summarize-selection-chatgpt",
      name: "Summarize selection with ChatGPT",
      editorCallback: async (editor, view) => {
        const selectedText = editor.getSelection();
        if (!selectedText) {
          new import_obsidian.Notice("No text selected.");
          return;
        }
        if (!this.settings.openAiApiKey) {
          new import_obsidian.Notice(
            "OpenAI API Key not set. Please configure it in the plugin settings."
          );
          return;
        }
        try {
          new import_obsidian.Notice("Summarizing with ChatGPT...");
          const systemPrompt = "You are a helpful assistant that summarizes text concisely.";
          const userPrompt = "Please summarize the following text:";
          const summary = await callChatGPT(
            this.settings.openAiApiKey,
            this.settings.defaultModel,
            systemPrompt,
            userPrompt,
            selectedText
          );
          editor.replaceSelection(summary);
          new import_obsidian.Notice("Summary complete!");
        } catch (error) {
          console.error("Error summarizing with ChatGPT:", error);
          new import_obsidian.Notice(
            `Error summarizing: ${error.message}. Check console for details.`
          );
        }
      }
    });
    this.addSettingTab(new AiLifeAssistantSettingTab(this.app, this));
    console.log("AI Life Assistant plugin loaded.");
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(AI_ASSISTANT_VIEW_TYPE);
    console.log("AI Life Assistant plugin unloaded.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async callOpenAI(systemPrompt, userPrompt, context = "") {
    if (!this.settings.openAiApiKey) {
      new import_obsidian.Notice(
        "OpenAI API Key not set. Please configure it in the plugin settings."
      );
      throw new Error("OpenAI API Key not set.");
    }
    return callChatGPT(
      this.settings.openAiApiKey,
      this.settings.defaultModel,
      systemPrompt,
      userPrompt,
      context
    );
  }
  async activateView() {
    if (this.app.workspace.getLeavesOfType(AI_ASSISTANT_VIEW_TYPE).length > 0) {
      this.app.workspace.detachLeavesOfType(AI_ASSISTANT_VIEW_TYPE);
      return;
    }
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (rightLeaf) {
      await rightLeaf.setViewState({
        type: AI_ASSISTANT_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(rightLeaf);
    } else {
      new import_obsidian.Notice("Could not open AI Assistant Panel in the right sidebar.");
    }
  }
};
var AiLifeAssistantSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Life Assistant Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key to use ChatGPT features.").addText(
      (text) => text.setPlaceholder("sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx").setValue(this.plugin.settings.openAiApiKey).onChange(async (value) => {
        this.plugin.settings.openAiApiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Model").setDesc("Select the default ChatGPT model to use.").addDropdown(
      (dropdown) => dropdown.addOption("o4-mini", "o4-mini").addOption("gpt-4.1-mini", "gpt-4.1-mini").addOption("gpt-4.1-nano", "gpt-4.1-nano").addOption("gpt-4o-mini", "gpt-4o-mini").setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
        this.plugin.settings.defaultModel = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
